import 'dart:collection';

/// A node in a [DoublyLinkedList].
///
/// This is a *non-intrusive* node wrapper: you can store any `E` without
/// requiring `E` to extend a special base class (unlike `dart:collection`'s
/// intrusive `LinkedListEntry`).
///
/// Important:
/// - [next] and [prev] are read-only for consumers. Only the list mutates links.
/// - A [Node] belongs to exactly one list at a time.
final class Node<E> {
  Node._(this.data);

  /// The value stored in this node.
  E data;

  Node<E>? _next;
  Node<E>? _prev;

  // O(1) ownership check to prevent cross-list corruption.
  DoublyLinkedList<E>? _owner;

  /// The next node in the list, or `null` if this is the tail or detached.
  Node<E>? get next => _next;

  /// The previous node in the list, or `null` if this is the head or detached.
  Node<E>? get prev => _prev;

  /// Whether this node is currently attached to a list.
  bool get isAttached => _owner != null;

  @override
  String toString() => data.toString();
}

/// A non-intrusive doubly linked list that implements [List].
///
/// This type is useful when you need:
/// - Stable [Node] handles (remove/move/insert near a known node in **O(1)**)
/// - Frequent inserts/removals at the ends or near known nodes
///
/// Trade-offs:
/// - Random access (`list[i]`) is **O(n)**, not O(1) like array-backed [List].
/// - Many `List` algorithms that rely heavily on indexing can become slower.
///   If you need heavy random-access algorithms, prefer a normal [List].
///
/// Common use cases:
/// - LRU caches (move accessed nodes to front)
/// - Editor buffers / splicing sequences
/// - Maintaining a sequence with frequent mid-list moves/removals by handle
///
/// Fail-fast behavior:
/// - Iterators throw [ConcurrentModificationError] on structural changes
///   (insert/remove/move/swap/clear/length changes).
/// - Element mutations (e.g., `list[i] = value` or `node.data = ...`) are not
///   structural and do not trigger CME.
/// - ListMixin reordering methods that operate via `[]=` (e.g., `sort`,
///   `shuffle`) do not update the modification count unless overridden.
class DoublyLinkedList<E> extends ListBase<E> {
  /// Creates a list containing [elements] (if provided).
  DoublyLinkedList([Iterable<E> elements = const []]) {
    addAll(elements);
  }

  /// Creates a list of [length] filled with [fill].
  factory DoublyLinkedList.filled(int length, E fill) {
    RangeError.checkNotNegative(length, 'length');
    final list = DoublyLinkedList<E>();
    if (length == 0) return list;

    // Batch-build without repeated traversals.
    list._appendManyFilled(length, fill);
    return list;
  }

  /// Creates a list of [length] values generated by [generator].
  factory DoublyLinkedList.generate(
    int length,
    E Function(int index) generator,
  ) {
    RangeError.checkNotNegative(length, 'length');
    final list = DoublyLinkedList<E>();
    for (var i = 0; i < length; i++) {
      list.append(generator(i));
    }
    return list;
  }

  Node<E>? _head;
  Node<E>? _tail;
  int _length = 0;

  // Structural modification counter for fail-fast iterators (not value writes).
  int _modCount = 0;

  /// The first node, or `null` if the list is empty.
  Node<E>? get head => _head;

  /// The last node, or `null` if the list is empty.
  Node<E>? get tail => _tail;

  void _touch() => _modCount++;

  bool _isOwned(Node<E> node) => identical(node._owner, this);

  void _ensureOwned(Node<E> node, [String argName = 'node']) {
    if (!_isOwned(node)) {
      throw ArgumentError.value(
        node,
        argName,
        'Node does not belong to this DoublyLinkedList (or is detached).',
      );
    }
  }

  Node<E> _newNode(E value) {
    final node = Node<E>._(value);
    node._owner = this;
    return node;
  }

  void _linkBetween(Node<E>? prev, Node<E>? next, Node<E> node) {
    node._prev = prev;
    node._next = next;

    if (prev == null) {
      _head = node;
    } else {
      prev._next = node;
    }

    if (next == null) {
      _tail = node;
    } else {
      next._prev = node;
    }

    node._owner = this;
  }

  void _unlinkFromList(Node<E> node, {required bool detachOwner}) {
    final prev = node._prev;
    final next = node._next;

    if (prev == null) {
      _head = next;
    } else {
      prev._next = next;
    }

    if (next == null) {
      _tail = prev;
    } else {
      next._prev = prev;
    }

    node._prev = null;
    node._next = null;

    if (detachOwner) node._owner = null;
  }

  void _detachChain(Node<E>? start) {
    var current = start;
    while (current != null) {
      final next = current._next;
      current
        .._owner = null
        .._next = null
        .._prev = null;
      current = next;
    }
  }

  Node<E> _nodeAt(int index) {
    if (index < 0 || index >= _length) {
      throw RangeError.index(index, this, 'index', null, _length);
    }

    // Choose the closer end.
    if (index <= (_length >> 1)) {
      var current = _head!;
      for (var i = 0; i < index; i++) {
        current = current._next!;
      }
      return current;
    } else {
      var current = _tail!;
      for (var i = _length - 1; i > index; i--) {
        current = current._prev!;
      }
      return current;
    }
  }

  /// Returns the node at [index].
  Node<E> nodeAt(int index) => _nodeAt(index);

  /// Returns the node at [index], or `null` if out of range.
  Node<E>? nodeAtOrNull(int index) {
    if (index < 0 || index >= _length) return null;
    return _nodeAt(index);
  }

  /// Returns the first node whose data equals [value], or `null` if none found.
  Node<E>? nodeOf(Object? value) {
    for (var n = _head; n != null; n = n._next) {
      if (n.data == value) return n;
    }
    return null;
  }

  /// Iterable over nodes from head -> tail (fail-fast on concurrent modification).
  Iterable<Node<E>> get nodes sync* {
    final expected = _modCount;
    var n = _head;
    while (n != null) {
      if (expected != _modCount) throw ConcurrentModificationError(this);
      final current = n;
      n = n._next;
      yield current;
    }
    if (expected != _modCount) throw ConcurrentModificationError(this);
  }

  /// Iterable over nodes from tail -> head (fail-fast on concurrent modification).
  Iterable<Node<E>> get nodesReversed sync* {
    final expected = _modCount;
    var n = _tail;
    while (n != null) {
      if (expected != _modCount) throw ConcurrentModificationError(this);
      final current = n;
      n = n._prev;
      yield current;
    }
    if (expected != _modCount) throw ConcurrentModificationError(this);
  }

  /// Adds [value] at the end and returns its [Node].
  Node<E> append(E value) {
    final node = _newNode(value);
    _linkBetween(_tail, null, node);
    _length++;
    _touch();
    return node;
  }

  /// Adds [value] at the beginning and returns its [Node].
  Node<E> prepend(E value) {
    final node = _newNode(value);
    _linkBetween(null, _head, node);
    _length++;
    _touch();
    return node;
  }

  /// Inserts [value] after [node] and returns the inserted [Node].
  Node<E> insertAfter(Node<E> node, E value) {
    _ensureOwned(node);
    final newNode = _newNode(value);
    _linkBetween(node, node._next, newNode);
    _length++;
    _touch();
    return newNode;
  }

  /// Inserts [value] before [node] and returns the inserted [Node].
  Node<E> insertBefore(Node<E> node, E value) {
    _ensureOwned(node);
    final newNode = _newNode(value);
    _linkBetween(node._prev, node, newNode);
    _length++;
    _touch();
    return newNode;
  }

  /// Unlinks [node] from this list (throws if the node is not owned by this list).
  void unlink(Node<E> node) {
    _ensureOwned(node);
    _unlinkFromList(node, detachOwner: true);
    _length--;
    _touch();
  }

  /// Attempts to unlink [node] from this list.
  ///
  /// Returns `true` if removed, `false` if [node] is not owned by this list.
  bool tryUnlink(Node<E> node) {
    if (!_isOwned(node)) return false;
    _unlinkFromList(node, detachOwner: true);
    _length--;
    _touch();
    return true;
  }

  /// Backwards-compatible name: returns whether [node] was removed.
  bool removeNode(Node<E> node) => tryUnlink(node);

  /// Moves [node] to the front (head) in O(1).
  void moveToFront(Node<E> node) {
    _ensureOwned(node);
    if (identical(node, _head)) return;

    _unlinkFromList(node, detachOwner: false);
    _linkBetween(null, _head, node);
    _touch();
  }

  /// Moves [node] to the back (tail) in O(1).
  void moveToBack(Node<E> node) {
    _ensureOwned(node);
    if (identical(node, _tail)) return;

    _unlinkFromList(node, detachOwner: false);
    _linkBetween(_tail, null, node);
    _touch();
  }

  /// Moves [node] to immediately after [target] in O(1).
  void moveAfter(Node<E> node, Node<E> target) {
    _ensureOwned(node, 'node');
    _ensureOwned(target, 'target');
    if (identical(node, target)) return;
    if (identical(target._next, node)) return; // already after

    _unlinkFromList(node, detachOwner: false);
    _linkBetween(target, target._next, node);
    _touch();
  }

  /// Moves [node] to immediately before [target] in O(1).
  void moveBefore(Node<E> node, Node<E> target) {
    _ensureOwned(node, 'node');
    _ensureOwned(target, 'target');
    if (identical(node, target)) return;
    if (identical(target._prev, node)) return; // already before

    _unlinkFromList(node, detachOwner: false);
    _linkBetween(target._prev, target, node);
    _touch();
  }

  /// Swaps the positions of [a] and [b] in O(1).
  ///
  /// Throws if either node is not owned by this list.
  void swapNodes(Node<E> a, Node<E> b) {
    _ensureOwned(a, 'a');
    _ensureOwned(b, 'b');
    if (identical(a, b)) return;

    // Normalize adjacency.
    if (identical(a._next, b)) {
      _swapAdjacent(a, b);
      _touch();
      return;
    }
    if (identical(b._next, a)) {
      _swapAdjacent(b, a);
      _touch();
      return;
    }

    _swapNonAdjacent(a, b);
    _touch();
  }

  void _swapAdjacent(Node<E> first, Node<E> second) {
    final prev = first._prev;
    final next = second._next;

    if (prev != null) prev._next = second;
    if (next != null) next._prev = first;

    second._prev = prev;
    second._next = first;

    first._prev = second;
    first._next = next;

    if (identical(_head, first)) _head = second;
    if (identical(_tail, second)) _tail = first;
  }

  void _swapNonAdjacent(Node<E> a, Node<E> b) {
    final aPrev = a._prev;
    final aNext = a._next;
    final bPrev = b._prev;
    final bNext = b._next;

    // Swap neighbors.
    a._prev = bPrev;
    a._next = bNext;
    b._prev = aPrev;
    b._next = aNext;

    if (a._prev != null) {
      a._prev!._next = a;
    } else {
      _head = a;
    }
    if (a._next != null) {
      a._next!._prev = a;
    } else {
      _tail = a;
    }

    if (b._prev != null) {
      b._prev!._next = b;
    } else {
      _head = b;
    }
    if (b._next != null) {
      b._next!._prev = b;
    } else {
      _tail = b;
    }
  }

  /// Reverses the list in-place in O(n).
  void reverse() {
    if (_length < 2) return;

    var current = _head;
    while (current != null) {
      final next = current._next;
      current._next = current._prev;
      current._prev = next;
      current = next;
    }

    final oldHead = _head;
    _head = _tail;
    _tail = oldHead;

    _touch();
  }

  // ---- ListBase overrides ----

  @override
  int get length => _length;

  @override
  set length(int newLength) {
    RangeError.checkNotNegative(newLength, 'newLength');
    if (newLength == _length) return;

    if (newLength < _length) {
      if (newLength == 0) {
        clear();
        return;
      }

      final newTail = _nodeAt(newLength - 1);
      final firstRemoved = newTail._next;

      // Cut.
      newTail._next = null;
      _tail = newTail;
      if (firstRemoved != null) firstRemoved._prev = null;

      // Detach removed nodes so external node refs don't keep the whole tail alive.
      _detachChain(firstRemoved);

      _length = newLength;
      _touch();
      return;
    }

    // newLength > _length
    // Only possible if E is nullable.
    if (null is E) {
      _touch();
      while (_length < newLength) {
        final node = _newNode(null as E);
        _linkBetween(_tail, null, node);
        _length++;
      }
      return;
    }

    throw UnsupportedError(
      'Cannot increase length of DoublyLinkedList<$E>. '
      'Use DoublyLinkedList<$E?> if you want null-padding, '
      'or add elements explicitly.',
    );
  }

  @override
  E operator [](int index) => _nodeAt(index).data;

  @override
  void operator []=(int index, E value) {
    _nodeAt(index).data = value;
    // Not a structural change: do NOT touch _modCount.
  }

  @override
  void add(E element) {
    append(element);
  }

  @override
  void addAll(Iterable<E> iterable) {
    final it = iterable.iterator;
    if (!it.moveNext()) return;

    // Build a chain once.
    Node<E>? firstNew;
    Node<E>? lastNew;
    var added = 0;

    do {
      final n = _newNode(it.current);
      if (firstNew == null) {
        firstNew = n;
        lastNew = n;
      } else {
        lastNew!._next = n;
        n._prev = lastNew;
        lastNew = n;
      }
      added++;
    } while (it.moveNext());

    // Splice chain.
    if (_tail == null) {
      _head = firstNew;
      _tail = lastNew;
    } else {
      _tail!._next = firstNew;
      firstNew._prev = _tail;
      _tail = lastNew;
    }

    _length += added;
    _touch();
  }

  @override
  void insert(int index, E element) {
    if (index < 0 || index > _length) {
      throw RangeError.index(index, this, 'index', null, _length + 1);
    }
    if (index == 0) {
      prepend(element);
      return;
    }
    if (index == _length) {
      append(element);
      return;
    }
    final anchor = _nodeAt(index);
    insertBefore(anchor, element);
  }

  @override
  void insertAll(int index, Iterable<E> iterable) {
    if (index < 0 || index > _length) {
      throw RangeError.index(index, this, 'index', null, _length + 1);
    }

    final it = iterable.iterator;
    if (!it.moveNext()) return;

    // Build chain once.
    Node<E>? firstNew;
    Node<E>? lastNew;
    var added = 0;

    do {
      final n = _newNode(it.current);
      if (firstNew == null) {
        firstNew = n;
        lastNew = n;
      } else {
        lastNew!._next = n;
        n._prev = lastNew;
        lastNew = n;
      }
      added++;
    } while (it.moveNext());

    final next = (index == _length) ? null : _nodeAt(index);
    final prev = (index == _length) ? _tail : next?._prev;

    // Splice chain between prev and next.
    if (prev == null) {
      _head = firstNew;
    } else {
      prev._next = firstNew;
      firstNew._prev = prev;
    }

    if (next == null) {
      _tail = lastNew;
    } else {
      next._prev = lastNew;
      lastNew._next = next;
    }

    _length += added;
    _touch();
  }

  @override
  E removeAt(int index) {
    final node = _nodeAt(index);
    final value = node.data;
    unlink(node);
    return value;
  }

  @override
  bool remove(Object? element) {
    for (var n = _head; n != null; n = n._next) {
      if (n.data == element) {
        unlink(n);
        return true;
      }
    }
    return false;
  }

  @override
  void removeWhere(bool Function(E element) test) {
    var n = _head;
    var touched = false;

    while (n != null) {
      final next = n._next;
      if (test(n.data)) {
        if (!touched) {
          _touch();
          touched = true;
        }
        _unlinkFromList(n, detachOwner: true);
        _length--;
      }
      n = next;
    }
  }

  @override
  void retainWhere(bool Function(E element) test) {
    var n = _head;
    var touched = false;

    while (n != null) {
      final next = n._next;
      if (!test(n.data)) {
        if (!touched) {
          _touch();
          touched = true;
        }
        _unlinkFromList(n, detachOwner: true);
        _length--;
      }
      n = next;
    }
  }

  @override
  void clear() {
    if (_length == 0) return;
    _touch();
    _detachChain(_head);
    _head = null;
    _tail = null;
    _length = 0;
  }

  @override
  E get first {
    if (_length == 0) throw StateError('No elements');
    return _head!.data;
  }

  @override
  E get last {
    if (_length == 0) throw StateError('No elements');
    return _tail!.data;
  }

  @override
  E get single {
    if (_length != 1) throw StateError('Not a single element');
    return _head!.data;
  }

  @override
  int indexOf(Object? element, [int start = 0]) {
    if (start < 0) start = 0;
    var i = 0;
    for (var n = _head; n != null; n = n._next) {
      if (i >= start && n.data == element) return i;
      i++;
    }
    return -1;
  }

  @override
  int lastIndexOf(Object? element, [int? start]) {
    var i = _length - 1;
    for (var n = _tail; n != null; n = n._prev) {
      if (start == null || i <= start) {
        if (n.data == element) return i;
      }
      i--;
    }
    return -1;
  }

  @override
  Iterator<E> get iterator => _DoublyLinkedListIterator<E>(this);

  @override
  Iterable<E> get reversed sync* {
    final expected = _modCount;
    var n = _tail;
    while (n != null) {
      if (expected != _modCount) throw ConcurrentModificationError(this);
      final current = n;
      n = n._prev;
      yield current.data;
    }
    if (expected != _modCount) throw ConcurrentModificationError(this);
  }

  @override
  String toString() => '[${join(', ')}]';

  // ---- internal helpers ----

  void _appendManyFilled(int count, E value) {
    // Builds in O(count) with one _touch.
    Node<E>? firstNew;
    Node<E>? lastNew;

    for (var i = 0; i < count; i++) {
      final n = _newNode(value);
      if (firstNew == null) {
        firstNew = n;
        lastNew = n;
      } else {
        lastNew!._next = n;
        n._prev = lastNew;
        lastNew = n;
      }
    }

    _head = firstNew;
    _tail = lastNew;
    _length = count;
    _touch();
  }
}

final class _DoublyLinkedListIterator<E> implements Iterator<E> {
  _DoublyLinkedListIterator(this._list)
      : _expectedModCount = _list._modCount,
        _next = _list._head;

  final DoublyLinkedList<E> _list;
  final int _expectedModCount;

  Node<E>? _next;
  Node<E>? _current;

  @override
  E get current => _current!.data;

  @override
  bool moveNext() {
    if (_expectedModCount != _list._modCount) {
      throw ConcurrentModificationError(_list);
    }
    final n = _next;
    if (n == null) {
      _current = null;
      return false;
    }
    _current = n;
    _next = n._next;
    return true;
  }
}
